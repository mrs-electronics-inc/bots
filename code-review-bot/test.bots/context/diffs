diff --git a/.bots/instructions.md b/.bots/instructions.md
index b4ad267..deb3f5a 100644
--- a/.bots/instructions.md
+++ b/.bots/instructions.md
@@ -1,6 +1,7 @@
 - Make sure that the pull request title follows the conventional commit style.
 	- Alert the developer if the title is in the wrong format.
-	- Example of a correct title: fix: some bug
-	- Example of an incorrect title: Resolves "#18 - some bug"
+	- Example of a correct title: `fix: some bug`.
+	- Example of an incorrect title: `Resolves "#18 - some bug"`.
+	- The scope portion is NOT required in the PR title.
 - Make sure that the `CHANGELOG.md` file is included in the diffs.
 	- Remind the PR author that the changelog must be updated with each PR.
diff --git a/.github/workflows/code-review.yaml b/.github/workflows/code-review.yaml
index 54caa88..b5c50f6 100644
--- a/.github/workflows/code-review.yaml
+++ b/.github/workflows/code-review.yaml
@@ -9,7 +9,7 @@ jobs:
     runs-on: ubuntu-latest
 
     container:
-      image: ghcr.io/mrs-electronics-inc/bots/code-review:0.10.0-rc6
+      image: ghcr.io/mrs-electronics-inc/bots/code-review:0.10.0-rc14
       volumes:
         - ${{ github.workspace }}:/repo
 
diff --git a/CHANGELOG.md b/CHANGELOG.md
index e088f01..9d1aa70 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,7 +1,8 @@
 # Changelog
 
-## v0.10.0 (upcoming)
+## v0.10.0
 
+- [#39](https://github.com/mrs-electronics-inc/bots/pull/39) - feat: collect JSON context
 - [#37](https://github.com/mrs-electronics-inc/bots/pull/37) - feat: improve bot response
 - [#36](https://github.com/mrs-electronics-inc/bots/pull/36) - feat: system prompt improvements
 
diff --git a/code-review/Dockerfile b/code-review/Dockerfile
index 42c2cc9..8def8f0 100644
--- a/code-review/Dockerfile
+++ b/code-review/Dockerfile
@@ -4,7 +4,7 @@ SHELL ["/bin/bash", "-c"]
 
 # Install core packages
 RUN apt update \
-    && apt install -y git wget gpg curl jq gettext file
+    && apt install -y git wget gpg curl jq gettext file bat
  
 # Install python packages
 COPY requirements.txt .
@@ -30,6 +30,7 @@ RUN git config --global --add safe.directory /repo
 COPY gitlab_code_review.sh /bin
 COPY github_code_review.sh /bin
 COPY collect_context.sh /bin
+COPY collect_context.py /bin
 COPY generate_llm_review.sh /bin
 COPY generate_llm_review.py /bin
 COPY post_gitlab_review_comment.py /bin
diff --git a/code-review/collect_context.py b/code-review/collect_context.py
new file mode 100755
index 0000000..a97bc11
--- /dev/null
+++ b/code-review/collect_context.py
@@ -0,0 +1,109 @@
+#!/usr/bin/env python3
+"""
+Collect context for code review and save as JSON.
+
+This script collects context for code review from either GitLab or GitHub,
+including details, comments, diffs, and file contents, and saves them as JSON.
+"""
+import os
+import json
+import subprocess
+import sys
+
+
+def read_context_file(file_path):
+    """Read content from a context file."""
+    try:
+        with open(file_path, 'r') as f:
+            if file_path.endswith('.json'):
+                return json.load(f)
+            else:
+                return f.read()
+    except FileNotFoundError:
+        print(f"Warning: Context file not found: {file_path}", file=sys.stderr)
+        return ""
+
+
+def collect_file_contents(changed_files, max_count=20, max_lines=400):
+    """Collect contents of changed files."""
+    file_contents = {}
+    count = 0
+
+    for file_path in changed_files:
+        if count >= max_count:
+            break
+
+        file_path = file_path.strip()
+        if not file_path or not os.path.isfile(file_path):
+            continue
+
+        # Check if it's a text file
+        try:
+            result = subprocess.run(
+                ['file', '-b', '--mime-type', file_path],
+                capture_output=True,
+                text=True,
+                check=True
+            )
+            mime_type = result.stdout.strip()
+
+            if not mime_type.startswith('text/'):
+                continue
+
+            # Check line count
+            with open(file_path, 'r') as f:
+                lines = f.readlines()
+
+            if len(lines) >= max_lines:
+                continue
+
+            # Read file content using batcat so it includes line numbers
+            batcat_result = subprocess.run(
+                ['batcat', '--style=numbers,plain',
+                    '--decorations=always', file_path],
+                capture_output=True,
+                text=True,
+                check=True
+            )
+
+            file_contents[file_path] = batcat_result.stdout
+            count += 1
+
+        except Exception as e:
+            print(f"Error processing file {file_path}: {e}", file=sys.stderr)
+            continue
+
+    return file_contents
+
+
+def main():
+    """Main function to collect context."""
+    print("Collecting context...")
+
+    # Read context from files
+    context = {}
+    context['details'] = read_context_file('.bots/context/details.json')
+    context['comments'] = read_context_file('.bots/context/comments.json')
+    context['diffs'] = read_context_file('.bots/context/diffs')
+
+    # Get changed_files
+    changed_files = os.getenv('CHANGED_FILES', '').splitlines()
+
+    # Collect file contents
+    file_contents = collect_file_contents(changed_files)
+    context['selected_current_files'] = file_contents
+    context['changed_files'] = changed_files
+
+    # Save context as JSON
+    output_path = '.bots/context.json'
+    try:
+        with open(output_path, 'w') as f:
+            json.dump(context, f, indent=2)
+        print(f"Context saved to {output_path}")
+    except Exception as e:
+        print(f"Error saving context: {e}", file=sys.stderr)
+        sys.exit(1)
+
+
+if __name__ == '__main__':
+    main()
diff --git a/code-review/collect_context.sh b/code-review/collect_context.sh
index be50480..ac18855 100755
--- a/code-review/collect_context.sh
+++ b/code-review/collect_context.sh
@@ -10,66 +10,35 @@ echo "Collecting context..."
 
 mkdir -p .bots/context
 
-changed_files=""
+CHANGED_FILES=""
 
 if [ "$PLATFORM" == "gitlab" ]; then
     # Collect the merge request details
-    glab mr view $CI_MERGE_REQUEST_IID > .bots/context/details
+    glab mr view $CI_MERGE_REQUEST_IID --output json | jq '{title: .title, body: .description, author: .author, state: .state}' > .bots/context/details.json
     # Collect the merge request comments
     # For some reason the API returns them newest to oldest, so we have to
     # reverse them with jq
-    glab api "projects/$CI_MERGE_REQUEST_PROJECT_ID/merge_requests/$CI_MERGE_REQUEST_IID/notes" | jq '[reverse | .[] | {username: .author.username, name: .author.name, timestamp: .created_at, body: .body, id: .id}]' > .bots/context/comments
+    glab api "projects/$CI_MERGE_REQUEST_PROJECT_ID/merge_requests/$CI_MERGE_REQUEST_IID/notes" | jq '[reverse | .[] | {username: .author.username, name: .author.name, timestamp: .created_at, body: .body, id: .id}]' > .bots/context/comments.json
     # Collect the diffs
     glab mr diff $CI_MERGE_REQUEST_IID --raw > .bots/context/diffs
     # Collect the names of the changed files
     git fetch origin $CI_MERGE_REQUEST_TARGET_BRANCH_NAME
-    changed_files=$(git diff origin/$CI_MERGE_REQUEST_TARGET_BRANCH_NAME --name-only)
+    CHANGED_FILES=$(git diff origin/$CI_MERGE_REQUEST_TARGET_BRANCH_NAME --name-only)
 elif [ "$PLATFORM" == "github" ]; then
     # Collect the pull request details
-    gh pr view $GITHUB_HEAD_REF > .bots/context/details
+    gh pr view $GITHUB_HEAD_REF --json title,body,author,state > .bots/context/details.json
     # Collect the pull request comments
-    gh api "repos/$GITHUB_REPOSITORY/issues/$PULL_REQUEST_NUMBER/comments" | jq '[.[] | {username: .user.login, timestamp: .created_at, body: .body, id: .id}]' > .bots/context/comments
+    gh api "repos/$GITHUB_REPOSITORY/issues/$PULL_REQUEST_NUMBER/comments" | jq '[.[] | {username: .user.login, timestamp: .created_at, body: .body, id: .id}]' > .bots/context/comments.json
     # Collect the diffs
     gh pr diff $GITHUB_HEAD_REF > .bots/context/diffs
     # Collect the names of the changed files
-    changed_files=$(gh pr diff $GITHUB_HEAD_REF --name-only)
+    CHANGED_FILES=$(gh pr diff $GITHUB_HEAD_REF --name-only)
 else
     echo "Error: PLATFORM environment variable must be 'gitlab' or 'github'."
     exit 1
 fi
 
-context_files=("details" "diffs" "comments")
-# Combine context into a single `.bots/context.md` file
-for f in "${context_files[@]}"; do
-    echo -e "\n\n===== BEGIN CONTEXT: $f =====\n\n"; cat ".bots/context/$f"; echo -e "\n\n===== END CONTEXT: $f =====\n\n"
-done > .bots/context.md
+export CHANGED_FILES
 
-echo -e "changed files:\n$changed_files"
-if [ -z "$changed_files" ]; then
-    echo "Warning: No changed files detected."
-fi
-count=0
-max_count=10
-# Iterate through each changed file
-while IFS= read -r file; do
-    # Check if the file exists
-    if [[ -f "$file" ]]; then
-        # Only include text files
-        mime_type=$(file -b --mime-type "$file")
-        if [[ $mime_type == text/* ]]; then
-            # Count the number of lines in the file
-            line_count=$(wc -l < "$file")
-            # Check if the line count is less than 400
-            if (( line_count < 400 )); then
-                echo "===== BEGIN FILE: $file =====" >> .bots/context.md;
-                cat "$file" >> .bots/context.md;
-                echo "===== END FILE: $file =====" >> .bots/context.md
-                ((count++))
-                # Exit early if max_count reached
-                if (( count >= max_count )); then
-                    break
-                fi
-            fi
-        fi
-    fi
-done <<< "$changed_files"
+# Run the Python script to collect context into JSON
+collect_context.py
diff --git a/code-review/generate_llm_review.py b/code-review/generate_llm_review.py
index 0fb92b4..c099c2f 100755
--- a/code-review/generate_llm_review.py
+++ b/code-review/generate_llm_review.py
@@ -5,7 +5,7 @@
 Input Files:
 - /bots/system-prompts/review.md: System prompt template with placeholders
 - .bots/instructions.md: Repository-specific instructions (optional)
-- .bots/context.md: Context information about the code changes to review
+- .bots/context.json: Context information about the code changes to review
 
 Output Files:
 - .bots/response/review.json: Generated review in JSON format with fields:
@@ -68,10 +68,10 @@ def main():
 
     # Read context
     try:
-        with open('.bots/context.md', 'r') as f:
+        with open('.bots/context.json', 'r') as f:
             context = f.read()
     except FileNotFoundError:
-        print("Error: Context file not found at .bots/context.md",
+        print("Error: Context file not found at .bots/context.json",
               file=sys.stderr)
         sys.exit(1)
 
diff --git a/code-review/generate_llm_review.sh b/code-review/generate_llm_review.sh
index 94cb3f9..a355f59 100755
--- a/code-review/generate_llm_review.sh
+++ b/code-review/generate_llm_review.sh
@@ -1,7 +1,7 @@
 #!/bin/bash
 
 # This script generates the LLM review.
-# It expects the .bots/context.md file to exist.
+# It expects the .bots/context.json file to exist.
 echo "Generating LLM review..."
 
 # Use the name expected by llm-openrouter
diff --git a/code-review/system-prompts/review.md b/code-review/system-prompts/review.md
index 5a8111f..6fd2d93 100644
--- a/code-review/system-prompts/review.md
+++ b/code-review/system-prompts/review.md
@@ -8,7 +8,9 @@ YOU MUST strictly adhere to the "Style" and "Response Fields" instructions menti
 
 Please carefully review the $CHANGE_NAME details and comments. Also take a look at the git diffs.
 
-The current contents of several of the changed files are also included in your context. Only non-binary files under 400 lines are included, and only a maximum of 10 files are included.
+The current contents of several of the changed files are also included in your context in the `selected_current_files` field.
+- Not every file is included in the context.
+- The file contents are generated with the `batcat` command to add line numbers.
 
 Follow the given JSON schema for your output.
   - A post-processing tool will convert each field into its own Markdown section in the final output.
